# 回溯算法

由于有些问题无法通过for循环直接求出, 需要用到回溯算法, 

回溯算法需要用到递归, 在分析结构时,不要按照代码运行逻辑进行分析, **而应当抽象成一颗多叉树**(每个节点都是一个返回值)

```c++
status backtracking(....)
{
    if(终止条件)
    {
        return ...;
    }
    for(auto it : range)
    {
        return ...;
    }
}
```



## 1.1 组合问题



##  1.1.1 [77组合问题](https://leetcode.cn/problems/combinations/description/)

![image-20240902150456551](./photo/image-20240902150456551.png)

**回溯算法占用空间并且费时, 请 二刷时一题多解**

```c++
class Solution {
public:

    vector<vector<int>> res ;
    void backtracking(int cur_num,int n ,int k , vector<int> arr){
        if((n-cur_num+1)<k-arr.size()) return ; //可填充的数据少于需要填充的数据
        if(arr.size()==k)
        {
            res.push_back(arr);
            return ;
        }
        for(int i = cur_num ; i <=n ; i++)
        {
            arr.push_back(i);
            backtracking( i+1,n , k , arr);
            arr.pop_back(); //回到上一个节点 继续添加
        }
    }
    vector<vector<int>> combine(int n, int k) {
        vector<int> arr;
        backtracking(1,n,k,arr);
        return res ;  
    }
};
```





### 	1.1.2 [电话号码](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=problem-list-v2&envId=xhXnJaos)

![image-20240902172449819](./photo/image-20240902172449819.png)

```c++
class Solution {
public:
    vector<string> res ;
    unordered_map<int ,string> hash_table ;
    void backtracking( int digits_idx ,string words ,string digits)
    {
        if(words.size()==digits.size())  
        {
            res.push_back(words);
            return ;
        }
        int num = digits[digits_idx] - '0';
        for(int i = 0 ; i<hash_table[num].size();i++)
        {
            words.push_back(hash_table[num][i]);
            backtracking(  digits_idx+1, words , digits);
            words.pop_back();
        }
    }        
   
    vector<string> letterCombinations(string digits) 
    {
        if(digits=="") return res;
        hash_table[2] ="abc";
        hash_table[3] ="def";
        hash_table[4] ="ghi";
        hash_table[5] ="jkl";
        hash_table[6] ="mno";
        hash_table[7] ="pqrs";
        hash_table[8] ="tuv";
        hash_table[9] ="wxyz";
        backtracking(  0 ,"",digits);
        return res;
    }
};
```

**做这道题需要注意一下: 只有当需要访问下一个键值对,即下一个数字时,才算是进入下一层递归**
