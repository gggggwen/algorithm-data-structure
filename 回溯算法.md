# 回溯算法

由于有些问题无法通过for循环直接求出, 需要用到回溯算法, 

回溯算法需要用到递归, 在分析结构时,不要按照代码运行逻辑进行分析, **而应当抽象成一颗多叉树**(每个节点都是一个返回值)

```c++
status backtracking(....)
{
    if(终止条件)
    {
        return ...;
    }
    for(auto it : range)
    {
        return ...;
    }
}
```



## 1.1 组合问题



### 	1.1.1 [77组合问题](https://leetcode.cn/problems/combinations/description/)

![image-20240902150456551](./photo/image-20240902150456551.png)

**回溯算法占用空间并且费时, 请 二刷时一题多解**

```c++
class Solution {
public:

    vector<vector<int>> res ;
    void backtracking(int cur_num,int n ,int k , vector<int> arr){
        if((n-cur_num+1)<k-arr.size()) return ; //可填充的数据少于需要填充的数据
        if(arr.size()==k)
        {
            res.push_back(arr);
            return ;
        }
        for(int i = cur_num ; i <=n ; i++)
        {
            arr.push_back(i);
            backtracking( i+1,n , k , arr);
            arr.pop_back(); //回到上一个节点 继续添加
        }
    }
    vector<vector<int>> combine(int n, int k) {
        vector<int> arr;
        backtracking(1,n,k,arr);
        return res ;  
    }
};
```





### 	1.1.2 [电话号码](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=problem-list-v2&envId=xhXnJaos)

![image-20240902172449819](./photo/image-20240902172449819.png)

```c++
class Solution {
public:
    vector<string> res ;
    unordered_map<int ,string> hash_table ;
    void backtracking( int digits_idx ,string words ,string digits)
    {
        if(words.size()==digits.size())  
        {
            res.push_back(words);
            return ;
        }
        int num = digits[digits_idx] - '0';
        for(int i = 0 ; i<hash_table[num].size();i++)
        {
            words.push_back(hash_table[num][i]);
            backtracking(  digits_idx+1, words , digits);
            words.pop_back();
        }
    }        
   
    vector<string> letterCombinations(string digits) 
    {
        if(digits=="") return res;
        hash_table[2] ="abc";
        hash_table[3] ="def";
        hash_table[4] ="ghi";
        hash_table[5] ="jkl";
        hash_table[6] ="mno";
        hash_table[7] ="pqrs";
        hash_table[8] ="tuv";
        hash_table[9] ="wxyz";
        backtracking(  0 ,"",digits);
        return res;
    }
};
```

**做这道题需要注意一下: 只有当需要访问下一个键值对,即下一个数字时,才算是进入下一层递归**



### 	1.1.3 [组合问题Ⅱ](https://leetcode.cn/problems/combination-sum-ii/description/)

![image-20240903212955810](./photo/image-20240903212955810.png)

遇到此题首先先排序-----升序排列

如果说采用`leetcode39组合总和`的代码会发现**由于原数组存在两个重复的1**导致返回式中有重复的组合。

导致这样是由于该循环的无记忆性, 即在同一树层中的处理是完全相互独立的

```c++
class Solution {
public:
   vector<vector<int>>ans;
   vector<int>path;
   void backtrack(vector<int>& candidates, int target,int index){
       if(target==0){
           ans.push_back(path);
           return;
       }
       for(int i=index;i<candidates.size();i++){
             if(target-candidates[i]<0) continue  ;
             else 
             {
                path.push_back(candidates[i]);
                backtrack(candidates , target-candidates[i] , i);
                path.pop_back();
             } 
           }
       }
   
   vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
       sort(candidates.begin(),candidates.end());
       backtrack(candidates,target,0);
       return ans;
   }
};
```

我们考虑加入一个bool类型数组`used`来记录每个元素的使用情况,

```c++
	vector<bool> using ; //表示正在使用
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        // 初始化
        res.clear();
        path.clear();
        using.assign(candidates.size(), false);

        // 排序以便于去重
        sort(candidates.begin(), candidates.end());  
        backtrack(candidates, target, 0);
        return res;
    }
```

<font color= red>**由于题干允许树枝重复,但是不允许树层重复**</font>

**如果说 前一个元素和当前元素值相同且正在使用,那么说明可以使用当前元素**

**如果说 前一个元素和当前元素值相同且不在使用, 那么说明不可以使用当前元素**

```c++
        for (int i = idx; i < candidates.size(); i++) {
            // 跳过重复元素
            if (i > 0 && candidates[i] == candidates[i-1] && !using[i-1]) continue;

            // 如果剩余的目标值小于当前候选值，则结束循环
            if (target - candidates[i] < 0) continue;

            path.push_back(candidates[i]);
            using[i] = true;
            backtrack(candidates, target - candidates[i], i + 1);
            using[i] = false;
            path.pop_back();
        }
```





## 1.2 分割问题



### 	1.2.1  [leetcode131 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/)

![image-20240904190226734](./photo/image-20240904190226734.png)

看似无从下手,实际上回文串的分割也可以模拟回溯过程。

在进行回溯代码构建之前,我们需要一个**判断字符串是否为回文字符串的代码**:

```c++
    //原来判断回文也可以这么写!!!!!
	bool isPalindrome ( string s , int start, int end)
    {
        while(start<end)
        {
            if(s[start]!=s[end]) return false ;
            start++;
            end--;
        }
        return true ;
    }
```



好那么我们来分析回溯部分怎么编写:

在每一层递归代码执行前需要传入本次递归在字符串中索引的开始`start`, 这个`start` 是由于前面(到start-1结束)出现了回文字符串,故进行了分割,而分割后,新的子字符串起点为`start`;

```c++
        for(int i =start ; i<s.size();i++)
        {
            if(!isPalindrome(s,start,i)) continue ; //若[start,i(end)] 非回文字符串
            path.push_back(s.substr(start,i-start+1));
            backtrack(s, i+1);  //start= i+1 ,进行切割
            path.pop_back(); //回溯
        }
```

那么递归的终点就是---**完成了对字符串的切割,即start>=s.size()** 

```c++
        if(start>=s.size())
        {
            res.emplace_back(path)  ;
            return ;        
        }
```



**完整实现:**

```c++
class Solution {
public:
    vector<vector<string>> res ;
    vector<string> path ;
    bool isPalindrome ( string s , int start, int end)
    {
        while(start<end)
        {
            if(s[start]!=s[end]) return false ;
            start++;
            end--;
        }
        return true ;
    }
    void backtrack(string s , int start)
    {
        if(start>=s.size())
        {
            res.emplace_back(path)  ;
            return ;        
        }
        for(int i =start ; i<s.size();i++)
        {
            if(!isPalindrome(s,start,i)) continue ;
            path.push_back(s.substr(start,i-start+1));
            backtrack(s, i+1);
            path.pop_back();
        }
    }
    vector<vector<string>> partition(string s) 
    {
        backtrack(s,0);
        return res;
    }
};
```





### 	1.2.2 [ leetcode93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

![image-20240905195720121](./photo/image-20240905195720121.png)

**<font size=4>设计思路:</font>**

- 设计一个**`count` 来记录切片次数 ,当切片数`==3`时准备返回(这个设计很巧妙**,注意不是上题的`start>=s.size()`)

```C++
        if(count==0)
        {
            if(!isValid(s,start , s.size()-1)) return ; //需要判断最后一个字符串是否合法
            res.push_back(s); 
            return ;
        }
```

- 设计一个函数`isValid(string & s, int start ,int end)`来确保预切割的字符串是否合法

```c++
    bool isValid(string s, int start , int end )
    {
        if(start>end) return false ;

        string temp = s.substr(start , end-start+1);
        if((temp[0]=='0'&& temp.size()>1) || temp.size()>3||stoi(temp)>255)
        {
            return false;
        }
        return true;
    }
```

[^if(start&gt;end) return false ;]: 注意一定要判断是否字符串长度为零

- 在遍历时直接在`string s`上进行'.'的插入 , 如果想传入temp 临时变量存储string太麻烦了

```c++
        for(int i = start ; i<s.size();i++)
        {
            if(!isValid(s, start ,i)) return  ;
            s.insert(i+1 , 1,'.');
            backtrack(s, i+2 , count-1);
            s.erase(i+1 , 1);
        }
```



**<font size=4>具体实现:</font>**

```c++
class Solution {
public:
    vector<string>res;
    bool isValid(string s, int start , int end )
    {
        if(start>end) return false ;
        //取数
        string temp = s.substr(start , end-start+1);
        if((temp[0]=='0'&& temp.size()>1) || temp.size()>3||stoi(temp)>255)
        {
            return false;
        }
        return true;
    }
    void backtrack(string s , int start , int count)
    {
        if(count==0)
        {
            if(!isValid(s,start , s.size()-1)) return ;
            res.push_back(s);
            return ;
        }
        for(int i = start ; i<s.size();i++)
        {
            if(!isValid(s, start ,i)) return  ;
            s.insert(i+1 , 1,'.');
            backtrack(s, i+2 , count-1);
            s.erase(i+1 , 1);
        }
    }
    vector<string> restoreIpAddresses(string s) 
    {
        if(s.size()<4|| s.size()>12) return vector<string>();
        backtrack(s,0 ,3);
        return res ;
    }
};
```

